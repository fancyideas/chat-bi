# 流程大全

从各种抽象程度分析核心流程，注意下面流程中没有包含“RAG检索表元数据” 节点的详细流程



# 综合流程

```mermaid
 graph TD
      A[用户输入提问“问数”] --> B[LLM分析用户意图]
      B --> C{意图是否明确?}
      C -->|不明确| D[LLM生成澄清问题]
      D --> E[向用户提问]
      E --> F[接收用户回答]
      F --> G[LLM重新分析意图<br/>原始提问+用户回答]
      G --> C
      C -->|明确| H[RAG检索表元数据]

      H --> I[发送意图+元数据给LLM]
      I --> J[LLM生成SQL]
      J --> K[校验SQL]
      K --> L{校验是否通过?}
      L -->|失败| M[记录校验错误]
      M --> I
      L -->|通过| N[执行SQL]
      N --> O[观察执行结果]
      O --> P{执行是否成功<br/>且结果正确?}
      P -->|否| Q[记录执行错误/问题]
      Q --> I
      P -->|是| R[返回最终结果给用户]
```

# 高抽象流程

```mermaid

 graph TD
      A[用户输入提问] --> B[阶段1: 意图理解与澄清]
      B --> C[RAG检索表元数据]
      C --> D[阶段2: SQL生成]
      D --> E[阶段3: SQL校验]
      E --> F{校验通过?}
      F -->|否| G[记录错误]
      G --> H{重试次数<br/>是否超限?}
      H -->|是| I[返回失败信息]
      H -->|否| D
      F -->|是| J[阶段4: 执行SQL]
      J --> K[阶段5: 结果验证]
      K --> L{结果正确?}
      L -->|否| M[记录问题]
      M --> N{重试次数<br/>是否超限?}
      N -->|是| I
      N -->|否| D
      L -->|是| O[返回结果给用户]
```

# 阶段1：意图理解与澄清（详细）
```mermaid
graph TD
      A[接收用户提问] --> B[发送给LLM分析意图]
      B --> C[LLM返回分析结果]
      C --> D{LLM判断:<br/>意图是否明确?}
      D -->|明确| E[提取明确的意图]
      E --> F[结束,进入RAG阶段]
      D -->|不明确| G[LLM生成澄清问题]
      G --> H[展示问题给用户]
      H --> I[等待用户回答]
      I --> J[接收用户补充信息]
      J --> K[合并:<br/>原始提问+历史对话+新回答]
      K --> B
```

  关键点：

  - LLM 需要返回两个信息：意图是否明确 + 澄清问题（如果不明确）

  - 保存对话历史，每次都把完整上下文发给 LLM





#   阶段2：SQL 生成（详细）
```mermaid
graph TD
      A[接收输入] --> B[准备上下文信息]
      B --> C[构建Prompt内容]
      C --> D{是否是<br/>首次生成?}
      D -->|是| E[Prompt包含:<br/>- 用户意图<br/>- 表元数据<br/>- 生成要求]
      D -->|否| F[Prompt包含:<br/>- 用户意图<br/>- 表元数据<br/>- 上次生成的SQL<br/>- 错误信息<br/>- 修复指导]

      E --> G[发送Prompt给LLM]
      F --> G
      G --> H[LLM处理并生成SQL]
      H --> I[接收LLM响应]
      I --> J[提取SQL语句]
      J --> K{是否成功<br/>提取到SQL?}
      K -->|否| L[错误: LLM未返回有效SQL]
      L --> M[记录错误]
      M --> N[返回错误给上层]
      K -->|是| O[记录生成的SQL]
      O --> P[返回SQL进入校验阶段]
```


  关键点：

  - 首次生成和重试生成的 Prompt 不同

  - 重试时要包含上次的错误信息，帮助 LLM 修复

  - 需要从 LLM 响应中正确提取 SQL（可能需要解析 markdown 代码块）





# 阶段3：SQL 校验（详细）
```mermaid
  graph TD
      A[接收生成的SQL] --> B[第1层: 语法校验]
      B --> C{语法正确?}
      C -->|否| Z[返回错误:<br/>语法错误详情]
      C -->|是| D[第2层: 元数据校验]
      D --> E[提取SQL中的表名和字段名]
      E --> F{表名是否<br/>都存在?}
      F -->|否| Z1[返回错误:<br/>不存在的表名]
      F -->|是| G{字段名是否<br/>都存在?}
      G -->|否| Z2[返回错误:<br/>不存在的字段名]
      G -->|是| H[第3层: 安全校验]
      H --> I{是否只是<br/>SELECT查询?}
      I -->|否| Z3[返回错误:<br/>不允许的操作类型]
      I -->|是| J[第4层: 数据库Dry-run]
      J --> K[执行: EXPLAIN 或 LIMIT 0]
      K --> L{数据库<br/>是否报错?}
      L -->|是| Z4[返回错误:<br/>数据库错误信息]
      L -->|否| M[校验通过]

      Z --> N[汇总错误信息]
      Z1 --> N
      Z2 --> N
      Z3 --> N
      Z4 --> N
      N --> O[返回给上层流程]
```
  关键点：

  - 每层校验失败都要返回具体的错误信息，帮助 LLM 修复

  - 使用 EXPLAIN 或 LIMIT 0 进行 Dry-run，不实际返回数据



#   阶段4：执行 SQL（详细）
```mermaid
  graph TD
      A[接收校验通过的SQL] --> B[记录SQL执行日志]
      B --> C[获取数据库连接]
      C --> D{连接是否成功?}
      D -->|否| E[错误: 数据库连接失败]
      E --> F[返回错误给上层]

      D -->|是| G[设置查询超时时间<br/>建议: 30-60秒]
      G --> H[执行SQL查询]
      H --> I{是否超时?}
      I -->|是| J[错误: 查询超时]
      J --> F

      I -->|否| K{是否有<br/>执行异常?}
      K -->|是| L[捕获异常信息]
      L --> M[错误: 执行错误<br/>包含详细错误信息]
      M --> F

      K -->|否| N[获取查询结果]
      N --> O[记录返回行数]
      O --> P[记录执行时间]
      P --> Q[构造结果对象:<br/>- SQL语句<br/>- 结果数据<br/>- 行数<br/>- 执行时间]
      Q --> R[返回结果进入验证阶段]
```

关键点：

+ 需要设置查询超时，防止慢查询
+ 要捕获所有可能的数据库异常
+ 记录执行时间和行数，用于后续分析
+ 返回的结果对象要包含完整信息



# 阶段5：结果验证（详细）
```mermaid
  graph TD
      A[接收SQL执行结果] --> B{是否有<br/>执行错误?}
      B -->|是| C[返回错误:<br/>执行错误信息]
      B -->|否| D{返回行数<br/>是否为0?}
      D -->|否| E[有数据返回]
      D -->|是| F[发送给LLM判断]
      F --> G[LLM分析:<br/>0行结果是否合理?]
      G --> H{LLM判断}
      H -->|合理| I[0行是正确结果]
      H -->|不合理| J[返回问题:<br/>应该有数据但返回0行]

      E --> K[第3层验证:<br/>LLM结果验证]
      I --> K

      K --> L[发送给LLM:<br/>用户问题+SQL+结果]
      L --> M[LLM判断结果是否<br/>真正回答了用户问题]
      M --> N{LLM判断}
      N -->|是| O[验证通过,<br/>结果正确]
      N -->|否| P[返回问题:<br/>LLM说明结果为何不符合预期]

      C --> Q[返回给上层流程]
      J --> Q
      P --> Q
      O --> R[返回给用户]
```

  关键点：

  - 第1层：检查执行错误（数据库报错）

  - 第2层：处理空结果（让 LLM 判断是否合理）

  - 第3层：LLM 深度验证（确保语义正确）



# 循环控制：重试次数限制
```mermaid
  graph TD
      A[SQL生成/校验/执行失败] --> B[记录错误信息]
      B --> C[重试计数器 +1]
      C --> D{重试次数 >= 最大限制?<br/>建议: 3-5次}
      D -->|是| E[构造失败响应]
      E --> F[返回给用户:<br/>- 尝试次数<br/>- 最后的错误<br/>- 最后生成的SQL]
      D -->|否| G[将错误信息附加到上下文]
      G --> H[返回LLM重新生成SQL]
```

  建议的最大重试次数：3-5 次

  - 太少：可能无法修复复杂问题

  - 太多：浪费时间和成本，且可能陷入死循环



# 超详细版本
```mermaid
graph TD
      Start[用户输入提问] --> A1[发送给LLM分析意图]

      %% ===== 阶段1: 意图理解与澄清 =====
      A1 --> A2[LLM返回分析结果]
      A2 --> A3{LLM判断:<br/>意图是否明确?}
      A3 -->|不明确| A4[LLM生成澄清问题]
      A4 --> A5[展示问题给用户]
      A5 --> A6[等待用户回答]
      A6 --> A7[接收用户补充信息]
      A7 --> A8[合并原始提问+历史对话+新回答]
      A8 --> A1

      A3 -->|明确| A9[提取明确的用户意图]

      %% ===== RAG检索 =====
      A9 --> B1[RAG检索相关表元数据]
      B1 --> B2[获取表结构、字段信息等]

      %% ===== 阶段2: SQL生成 =====
      B2 --> C1[初始化重试计数器=0]
      C1 --> C2[发送给LLM:<br/>用户意图+表元数据+错误信息如有]
      C2 --> C3[LLM生成SQL语句]

      %% ===== 阶段3: SQL校验 =====
      C3 --> D1[第1层: 语法校验]
      D1 --> D2{语法正确?}
      D2 -->|否| D_ERR1[错误: 语法错误详情]
      D2 -->|是| D3[第2层: 元数据校验]

      D3 --> D4[提取SQL中的表名和字段名]
      D4 --> D5{表名是否都存在?}
      D5 -->|否| D_ERR2[错误: 不存在的表名]
      D5 -->|是| D6{字段名是否都存在?}
      D6 -->|否| D_ERR3[错误: 不存在的字段名]

      D6 -->|是| D7[第3层: 安全校验]
      D7 --> D8{是否只是SELECT查询?}
      D8 -->|否| D_ERR4[错误: 不允许的操作类型]

      D8 -->|是| D9[第4层: 数据库Dry-run]
      D9 --> D10[执行EXPLAIN或LIMIT 0]
      D10 --> D11{数据库是否报错?}
      D11 -->|是| D_ERR5[错误: 数据库错误信息]

      %% 校验错误汇总
      D_ERR1 --> D_ERR[汇总校验错误信息]
      D_ERR2 --> D_ERR
      D_ERR3 --> D_ERR
      D_ERR4 --> D_ERR
      D_ERR5 --> D_ERR

      D_ERR --> RETRY1[重试计数器+1]
      RETRY1 --> RETRY_CHECK1{重试次数>=最大限制?<br/>建议3-5次}
      RETRY_CHECK1 -->|是| FAIL[构造失败响应:<br/>尝试次数+最后错误+最后SQL]
      FAIL --> END[返回失败信息给用户]
      RETRY_CHECK1 -->|否| C2

      %% ===== 阶段4: 执行SQL =====
      D11 -->|否| E1[校验通过]
      E1 --> E2[在数据库中执行SQL]
      E2 --> E3[获取执行结果]

      %% ===== 阶段5: 结果验证 =====
      E3 --> F1{是否有执行错误?}
      F1 -->|是| F_ERR1[错误: 执行错误信息]

      F1 -->|否| F2{返回行数是否为0?}
      F2 -->|否| F3[有数据返回]
      F2 -->|是| F4[发送给LLM判断]
      F4 --> F5[LLM分析: 0行结果是否合理?]
      F5 --> F6{LLM判断}
      F6 -->|合理| F7[0行是正确结果]
      F6 -->|不合理| F_ERR2[问题: 应该有数据但返回0行]

      %% 第3层验证
      F3 --> F8[第3层: LLM结果验证]
      F7 --> F8
      F8 --> F9[发送给LLM:<br/>用户问题+SQL+结果]
      F9 --> F10[LLM判断结果是否<br/>真正回答了用户问题]
      F10 --> F11{LLM判断}
      F11 -->|是| SUCCESS[验证通过]
      F11 -->|否| F_ERR3[问题: LLM说明结果<br/>为何不符合预期]

      %% 执行/验证错误汇总
      F_ERR1 --> F_ERR[汇总执行/验证错误信息]
      F_ERR2 --> F_ERR
      F_ERR3 --> F_ERR

      F_ERR --> RETRY2[重试计数器+1]
      RETRY2 --> RETRY_CHECK2{重试次数>=最大限制?}
      RETRY_CHECK2 -->|是| FAIL
      RETRY_CHECK2 -->|否| C2

      %% ===== 成功返回 =====
      SUCCESS --> RESULT[返回查询结果给用户]

      %% 样式定义
      classDef errorNode fill:#ffcccc,stroke:#ff0000
      classDef successNode fill:#ccffcc,stroke:#00aa00
      classDef decisionNode fill:#ffffcc,stroke:#aaaa00
      classDef processNode fill:#cce5ff,stroke:#0055aa

      %% 样式应用
      class D_ERR1,D_ERR2,D_ERR3,D_ERR4,D_ERR5,D_ERR,F_ERR1,F_ERR2,F_ERR3,F_ERR,FAIL errorNode
      class SUCCESS,RESULT,E1 successNode
      class A3,D2,D5,D6,D8,D11,RETRY_CHECK1,RETRY_CHECK2,F1,F2,F6,F11 decisionNode
```

